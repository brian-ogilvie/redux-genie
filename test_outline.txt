EACH OF THE BELOW NEEDS A TEST FOR BOTH THE RAILS AND DUCKS MODELS.

generic expect blocks- these may or may not be appropriate for each test, its a sampler

1. reducer updates store in response to thunk- 
2. getState() retrieves state
3. thunk returns a function- thunk unit test
4. action constant- returns the expected string
5. dispatch an individual action updates or returns state 

FINAL STRATEGY

1. store.spec.js

	- describe- "rails"

		- "its" for 1 - 6 of "Test Landscape" below

	- describes- "ducks"

		- "its" for 1 - 6 of "Test Landscape" below

2. logging "logging.spec.js" - Jonathan

	- only loggs in " process.env.mode = 'development' "
	- configures correctly when user chooses to have logging and when they choose "logging false"
	- lets add in process.env.test = true option
	- expect blocks:
		- logger fires in response to thunk dispatch


TEST LANDSCAPE:

1. multiple models "model.spec.js" - 

2. test the slice- generates each store key per variable "slice.spec.js"

3. CRUD option "crud.spec.js"

	- generates as expected 
	- generates as expected with and without and defined actions
	- expect blocks: CRUD should be threaded through:
		- constants
		- actions
		- reducers  

4. thunks "thunk.spec.js"

	- populates as expected when user wants to include in action file, and when they choose to have them defined in a separate file
	
	- populates correctly based on the way they should be listed on the yaml file: with endpoint and the action that should be fired in thunk's final dispatch method

6. defined actions "actions.spec.js"

	- populates correctly with or without CRUD option
	- expect blocks:
		- constants
		- action file
		- reducer

total of 12 test "set" - 6 for Rails, 6 for Ducks



